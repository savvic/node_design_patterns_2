// Generated by CoffeeScript 2.3.1
(function() {
  // NodeJS design patterns 2 ed.
  // code:
  // https://github.com/PacktPublishing/Node.js_Design_Patterns_Second_Edition_Code
  var EventEmitter, after, assert, download, fs, log, logger, mkdirp, numFile, path, pry, readFile, request, server, spider, spiderLinks, utilities, writeFile;

  log = console.log.bind(console);

  fs = require('fs');

  numFile = './fileA.txt';

  ({EventEmitter} = require('events'));

  server = require('http').createServer();

  pry = require('pry');

  assert = require('assert');

  logger = require('./logger.coffee');

  after = function(ms, fn) {
    return setTimeout(fn, ms);
  };

  utilities = require('./utilities');

  path = require('path');

  request = utilities.promisify(require('request'));

  mkdirp = utilities.promisify(require('mkdirp'));

  fs = require('fs');

  readFile = utilities.promisify(fs.readFile);

  writeFile = utilities.promisify(fs.writeFile);

  // PROMISE   ****************************************************************************************************************

  // To receive the fulfillment value or the error (reason) associated with the rejection, we use the then() method of the promise
  // promise.then([onFulfilled], [onRejected])
  // onFulfilled() is a function that will eventually receive the fulfillment value
  // onRejected() is another function that will receive the reason for the rejection

  // typical CPS - continous passing style:

  // asyncOperation(arg, (err, result) => {
  //   if(err) {
  //     // handle error
  //   }
  //   // do stuff with result
  //   });

  // promise way:

  // asyncOperation(arg)
  //   .then(result => {
  //     //do stuff with result
  //   }, err => {
  //     //handle error
  //   });

  // if we don't specify an onFulfilled() or onRejected() handler, the fulfillment value or rejection reasons are
  // automatically forwarded to the next promise in the chain.

  // asyncOperation(arg)
  //   .then(result1 => {
  //     //returns another promise
  //     return asyncOperation(arg2);
  //   })
  //   .then(result2 => {
  //     //returns a value
  //     return 'done';
  //   })
  //   .then(undefined, err => {
  //     //any error in the chain is caught here
  //   });
  spiderLinks = function(currentUrl, body, nesting) {
    var links, promise;
    promise = Promise.resolve();
    if (nesting === 0) {
      return promise;
    }
    links = utilities.getPageLinks(currentUrl, body);
    links.forEach(function(link) {
      return promise = promise.then(function() {
        return spider(link, nesting - 1);
      });
    });
    return promise;
  };

  spider = function(url, nesting) {
    var filename;
    filename = utilities.urlToFilename(url);
    return readFile(filename).then((function(body) {
      spiderLinks(url, body, nesting);
    }), function(err) {
      if (err.code != 'ENOENT') {
        throw err;
      }
      return download(url, filename).then(function(body) {
        spiderLinks(url, body, nesting);
      });
    });
  };

  download = function(url, filename) {
    log(`downloading ${url}`);
    return request(url).then(function(response) {
      var body;
      body = response.body;
      return mkdirp(path.dirname(filename));
    }).then(function() {
      return writeFile(filename, body);
    }).then(function() {
      log(`downloaded and saved ${url}`);
      return body;
    });
  };

  spider('https://www.ultimatum.group', 1).then(function() {
    return log('download completed');
  }).catch(function(err) {
    return log(err);
  });

}).call(this);
